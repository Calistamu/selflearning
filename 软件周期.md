# 2019.9.10
## 基本
微软sdl软件项目安全开发生命周期  
开发过程：需求分析、设计、开发、测试  
测试时有很多安全原则，比如：  
strcpy可能会有溢出，其中一个原则是不使用非安全函数  
测试阶段一定要进行安全性测试，比如Fuzzing测试  
  
看软件工程的书

## 什么是软件工程

CPU ：硬件（有物理实体）  
OS  ：硬件（就是数据、文件）  
APP ：软件发展的阶段：指令->函数（软件的优势：可复制、可复用）->改造CPU成一个能理解高级动作的执行器，此时执行的叫基于虚拟机的APP,而CPU执行的叫原生APP。

* 作业要求:  
          1.Git提交，要学一遍，git clone http:...  
          2.提交的是地址，git log提交记录，git log 越丰富分数越高；git diff比较版本

技术：工具、格式、标准、方法

# 《软件工程》自我学习

## 第一章 软件工程概述

   软件生命周期过程：定义、实现、评估、管理、变更、改进。  
   
   软件配置：程序（能够完成预定功能和性能的可执行的指令序列）、文档（开发、使用、维护程序所需要的图文资料）、数据（使程序能够适当地处理信息的数据结构）  
   
   软件工程学：提高软件的可维护性，减少软件维护的代价。  
   
   软件工程是开发、运行、维护和修复软件的系统方法。  

   软件危机：计算机软件的开发和维护过程中所遇到的一系列严重问题。  
   软件危机包括：1.如何开发软件，以满足对软件日益增长的需求2.如何维护数量不断膨胀的已有软件。

   软件工程三要素：方法、工具和过程

## 第二章 软件过程

   软件生命周期：软件定义、软件开发、运行维护。  
   
   生命周期模型：规定了把生命周期划分成哪些阶段及各个阶段的执行顺序。也称过程模型。

   瀑布模型：最广泛的过程模型。收集需求--分析--设计--编码--测试--维护。实际的瀑布模型是反馈环的，因为不可能不出错。  
   优点：强迫使用规范的方法（如结构化技术），严格规定了每个阶段必须提交的文档，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。  
   缺点：文档驱动的模型，很难全面正确地认识动态的软件产品。

   快速原型：快速建立起来的可以在计算机上运行的程序，所能完成的功能往往是最终产品能完成的功能的子集。  
   快速原型模型:快速建立一个能反应用户主要需求的原型系统，让用户在计算机上试用它，通过实践来了解系统的概貌。不带反馈环。收集需求--快速原型--构建--移交部署  
   优点：软件产品的开发基本上是按线性顺序进行的。快速。  

   增量模型：渐增模型。分析--设计--编码--测试。分批逐步向用户提交产品，每一次提交一个满足用户需求子集的可运行的产品。  
   优点：能在较短时间内向用户提交可完成一些有用的工作的产品，逐步增加产品功能可以使用户有充裕的时间学习和适应新产品。  
   缺点：新的增量构件集成到现有软件体系结构中，必须不破坏原来已经开发出的产品。

   螺旋模型：每个阶段之前都增加了风险分析的快速原型模型。
   优点：对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标，减少了过多测试或测试不足所带来的风险，在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没有本质区别。适用于内部开发的大规模软件项目。  
   缺点：风险驱动。

   喷泉模型 要避免过分无序，应该把一个线性过程作为总目标 迭代和无缝

   Rational统一过程（RUP）软件开发过程框架 迭代式开发




# 2019.9.17

编译器cl(windows)clang(linux)gcc将.cpp变成.exe的过程叫编译链接

0x80~0xFF没有对应的可显示的字符和符号，文本文件包含的是可打印字符，二进制文件包含00~FF的二进制数。

为什么要有编译和连接？程序的执行靠CPU，逻辑电路靠电平的高低来控制，

安全研究两大方向  
二进制安全，研究原生程序的安全，比如缓冲区溢出等，操作系统，计算机体系结构，二进制指令了解深入  
网络应用的安全（通常是脚本写的应用程序）数据泄露，逻辑校验不完整，较多是逻辑问题，跨站脚本攻击，通过提交框（例如微博评论）注入一段代码到网页，浏览器以为是提交的代码而不是用户评论，会自己执行，这可能会使用户密码等泄露，xss（跨站脚本攻击）

做实验：Http html 爬虫的编写 抓包器和协议解析

# 2019.9.18

clang 完成了编译链接两步的工作，.c-->.o编译-->.exe链接，多个.o形成exe，其中包括lib文件，lib文件包含多个api，这样的exe叫原生应用程序netive app,所有的脚本运行都必须使用原生应用程序的解析器来运行（比如python.exe,java.exe,浏览器等）。 


原生应用程序的特点：解析代码并直接运行、性能最好、开发相对较难  
原生应用程序开发难的原因：一般使用c/cpp的指针内存要深入理解，以及原生API多且杂    


要看的书：深入理解计算机系统、Unix环境高级变成、windows系统核心编程  

  ## 看原生应用程序  

  看二进制：windows---winjex,linux---bash 
  看反汇编也可看二进制：dumpbin objdump

## http以及html

从下到上：硬件（CPU、内存）---OS---原生APP(Chrome)三大基础功能：http client网络功能（从srv【服务器】上拿到html文件）、html的解析与显示，也叫渲染（标签化）、执行脚本（通常是网页相关的处理的过程，尤其是用于交互数据以及动态效果），因此是一个脚本执行器

google V8 Webkit脚本解析，我们可以做的是网络功能以及html解析，因此我们写爬虫，比价网，反爬虫（反爬虫），爬虫做游戏外挂

## 爬虫

header字段通常是浏览器的类型和版本，如果不设置，服务器可以根据你的请求而过滤掉，比如一看是python request的库，header是为了伪装成浏览器发送的请求。

socket编程，tcp以下的已做好

response=request.get返回的是state,200正常,404,403没有访问权限，500服务器内部崩溃，因此应该判断

response.content可以保存成文件，然后可以打开

lxml里面的存储结构etree，etree有很多不同的解析方法，比如Html,json,html.xpan的方法通过路径的方式定位tree中的元素，//div表示所有的div标签前面可以是任意，//div[class='']可以定位属性，还可以调用函数获得标签内部的内容，html/body/div是前面要具体的路径

$x('')xpath命令

# 2019.9.24

进入仓库，先设公钥
ssh-keygen -t ras -b 4096
putty windows的终端
有了公私钥以后不需要用户密码来登陆

     1、打开git bash
     2、执行生成公钥和私钥的命令：ssh-keygen -t ras -b 4096（为什么按三下，是因为有提示你是否需要设置密码，如果设置了每次使用Git都会用到密码，一般都是直接不写为空，直接回车就好了）。会在一个文件夹里面生成一个私钥 id_rsa和一个公钥id_rsa.pub。（可执行start ~ 命令，生成的公私钥在 .ssh的文件夹里面）
     3、执行查看公钥的命令：cat ~/.ssh/id_rsa.pub  

python -m pip install selenium requests lxml
包名错误或者网速太慢，如果网速慢就需要使用国内包的源（直接搜索python源）  
pythpon -m pip -i 连接
[更改国内镜像源，提交下载速度](https://blog.csdn.net/lambert310/article/details/52412059)
当我们的工程量大，写一个requirements.txt写入所有需要的包名，vps安装 
python -m pip -r requirements.txt一次性安装

接续lxml调用GDI的库进行渲染

爬虫设计数据提交，需要登陆

防火墙穿透
五元组
设置一些过滤规则
有一张可以用美元的信用卡、去国外买一个vps linode.com,在C上架一个代理服务器，A上的代理设置成C，A-C必有加密通道，到C解密，异或最简单，shadowsocks部署一个server，防火墙是黑名单规则
隧道，gotunnel，异或进行端口转发
elem_user=self.driver.find_element_
秒传是哈希值
selenium提供统一的接口，chromedriver,firefoxdriver
$x('//a[@class="left_tab_core"]')

找一个有用户提交以

有用户登陆功能，用户信息提交，并且能呈现给其他用户
跨站脚本执行，也就是如果用户提交的如果有脚本，但是没有过滤，就会被执行，一个商品表，一个评论表，用户Id表，时间，用户有一个编辑框，输入后，数据进入数据库
有一个有跨站脚本漏洞的程序,并成功利用这个漏洞

写一个爬虫，自动提交和验证网页有这样的漏洞，看页面会不会执行我提交的脚本，判断是否有漏洞

# 2019.10.8
xss  
用户A提交了脚本给server，用户B会执行这个脚本
假的登录弹窗，数据提交到A的后端，为什么？
在server端严格校验用户提交的数据中是否有可被执行的程序，因此一个好的网站应该对用户的提交进行过滤
sql注入  
 
argc表示Main()命令行参数的个数  
argv表示运行程序时用来存放命令行字符串参数的指针数组  
我们在敲命令行其实就是在向命令行工具的代码传入参数    
变量定义是为了告诉编译器要分配空间来存储变量  
java\python自己能判断变量需要多少的存储量，而C语言必须明确地告诉需要多少存储空间,c语言没有那么智能，strcpy传入的是指针，如果写入越界，可能会覆盖内部控制数据，
    
    #include<stdlib.h>
    #include<stdio.h>
    #include<string.h>
    int sub(char* x)
    {
	    char y[10];
	    strcpy_s(y, strlen(x), x);//拷贝目的地址，大小，拷贝的源，这个大小是为了判断大小是否越界，因此应该判断的是y的大小
	    return 0;
    }
    int mian(int arge, char** argv)
    {
	    char y[10];
	    if (arge > 1)
	    {
		  strcpy(y, argv[1]);
	    }
    }

* 属性--C/C++--代码生成：如果关闭了安全检查、基本运行时检查就不会给出错误信息，直接报错。  

如何从可执行文件中去恢复参数，push用来传参，call返回地址，从上到下：局部变量，返回地址，参数
缓冲区溢出及漏洞利用程序

漏洞库集：
[CVE](http://cve.mitre.org/?_blank)
[CNNVD](http://www.cnnvd.org.cn/blank) 
[CNVD](https://www.cnvd.org.cn/)

web程序的基本框架:html
一开始有一个服务器，httpserver的搭建，httpserver是一个程序，最著名的httpserver是httpd,启动，netstat去看一下端口的占用情况，启动之前和启动之后的80端口，前为关闭状态，后为监听状态，httpd在主机上有一个目录，可以放到任何一个有html的文件夹中，httpd 127.0.0.0 \a html就可以看这个网页中的信息，先取数据，根据Html渲染，执行脚本。

安装http server ，还可以进行抓包，这是一个静态的web服务器，实际生活中的是一个动态的网站，静态网站和动态网站最大的区别在于，每一次的Html都是有数据支撑新生成的（数据库）,一开始是C语言编程的，cgi，就是printf的结果重定位到http server上

Http server 有哪些

php非常适合处理web

写一些动态的脚本，php做一个乘法器，php get的全局变量

一个思维习惯：不要做重复性的工作，前人已经做过的工作就不需要再去做了，封装和复用，你做的东西要有接口，别人通过接口就能简单实用  

web开发的流程：  
用户提交的一般两种方式，get和post,后端处理，DB访问拼接回Html,通常返回Html\json\xml的数据，很多东西是重复共性的，那么别人就解决了共性问题的东西叫框架，flask\django,django是mvt的模式，也有mvc(model\view\control)模式，m是数据模型（数据库表结构），v就是功能列表，t页面模板决定最后用户看到是什么样子，每个应用这三个都不一样，关注不同进行开发，框架也进行了一些基础的安全处理。  
核心：定义数据模型、编写功能列表、定义页面模板

* 关系型数据库：数据表存储具有相同属性的对象，两张表存储，最好是引用另一张表的id，这个就叫做外键，不可重复的作为主键，二维数据一维化，这时候就会有多个外键，比如订单表存储的是商品和用户的外键。

先开发数据模型（查询的sql语句是需要拼接的），在进行网页开发（每个功能设计一个页面的模式，请求的地址）

两周学完django  
用django做东西有一个基础的orm，不必关注底层是怎么做的，只需要做到定义类，框架自动将类中的数据映射到表结构当中，以后要用的时候引用数据库的对象

抓包器抓一下整个响应的过程  
用httoserver建立一个web程序执行的过程，写一个简单的Php,返回显示在页面上，动态生成页面，pho调用数据库的裸操作
用框架构建一个web应用  
php用lera  
Python 用flask和django  

# 20.19.10.22
1. 一定要学的东西：  
  1.git和github的使用，pro git,看官方文档  
  2.markdown可对比，版本化管理，格式简洁化     
  3.原生应用程序（.c/.cpp编译链接成的exe||.c/.cpp/golang编译链接成的elf）和web（网络）应用程序  
2. 机器指令二进制，汇编是文本，机器指令与汇编一一对应，执行的是机器指令，机器指令到汇编的过程叫汇编，反之反汇编  
3. 程序执行过程，如何观察？调试器（debuger）看EIP  
4. 调试器：  
  1.VS自带的/工业级：windbg,gdb,vc,gnu  
  2.编译连接器（或两大平台）：  
    a.vc的在windows开发的完整工具链在vs总，cle,link,sdk等  
    b.gnu有gcc\libc\gdb  
  3.调试基本操作：断电、单步、反汇编、内存、寄存器
    * .c/.cpp源文件与汇编对应关系
5. 缓冲区溢出漏洞
  
       #define _CRT_SECURE_NO_WARNINGS

       #include <stdlib.h>
       #include <stdio.h>
       #include <string.h>

       int sub(char* x)
       {
        char y[10];
        strcpy(y, x);
        return 0;
        }

       int main(int argc, char** argv)
       {
        if (argc > 1)
        sub(argv[1]);
        printf("exit");
       }
       * 要存入ebp-main用于ret的时候回退

* c/c++直接和内存打交道，malloc动态显示声明，全局变量或局部变量隐式声明，编译器进行分配，尽量少使用全局变量，局部变量的效率很高  
* c语言面临的是平坦的内存空间，需要数据结构来组织数据，首先要知道底层数据的组织，二进制和缓冲区的错误主要是在数据组织上，web程序是逻辑性问题，没有考虑到用户输入的恶意性。
* 堆溢出漏洞，堆和栈是两种数据管理模型，堆对应着malloc和free，程序要处理数据，一开始无法预计所需要的存储空间有多大,malloc和free就满足需要多大分配多大，程序执行的时候可以多次Malloc，以及多次不定时free。有一个内存使用的双向链表，而这个链表本身也需要使用内存。malloc产生的是数据在前，头在后面，头会根据操作系统的版本而不一样，因此不同的版本链表头不一样。
* 代码没有问题，但是内存会崩溃，释放时内存崩溃可能是前面溢出了，崩溃之处并不是产生问题的地方。前[地址]+4写入后，因此导致了可以向任意地址写入任意信息，free没有数据抹除，而是将指针脱链

参数每四个字节都不一样

写了一段代码没有调用，如何执行？？？

# 2019.10.29

C语言没有解决内存的问题；.net提供了类和接口的方式，专注于应用；python和java主要解决了社会化协作问题，创造了很多基础程序库，库非常丰富，有包管理器；  
对于做安全的同学一定要深入底层，C语言没有被淘汰是因为基础软件必须使用C语言来开发，python\net\java的执行器都是用C语言开发的  
技术本身没有好坏，研究技术和工具  
做一个小的外挂，当所有计算结果为999时，将结果改成666，通过windg来调试，exe调用API来做基础的功能(可能是TextOut()属于GDI图形用户库，形成控件，将一个文字显示在界面上，printf的底层就可能调用的TextOut,有道词典的屏幕取词就是重载TextOut,每一次会存取当前页面的内容，当指到某一处的时候，就会知道所指的内容是什么)

老师发的.md里面的东西都要会，腾讯玄武实验室  
任何时间有任何问题，随时提问  

多线程与虚拟内存管理
进程创建和动态链接
[createthread](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread)
远程线程注入技术是什么？？？
程序的运行必须创建进程，那么可以看到异常的，可以把我们的
一定要看的书：unix环境高级编程和windows核心编程和深入理解计算机系统和[inter手册](https://software.intel.com/sites/default/files/managed/39/c5/325462-sdm-vol-1-2abcd-3abcd.pdf)
华为鸿蒙，兼容安卓的API，现在是操作系统适应应用程序  
线程是进程的执行流程
所有的函数，都是Main主线程调用createthread函数创建的进程